{"ast":null,"code":"const EventEmitter = require(\"events\");\n\nconst debug = require(\"debug\")(\"engine:socket\");\n\nclass Socket extends EventEmitter {\n  /**\n   * Client class (abstract).\n   *\n   * @api private\n   */\n  constructor(id, server, transport, req, protocol) {\n    super();\n    this.id = id;\n    this.server = server;\n    this.upgrading = false;\n    this.upgraded = false;\n    this.readyState = \"opening\";\n    this.writeBuffer = [];\n    this.packetsFn = [];\n    this.sentCallbackFn = [];\n    this.cleanupFn = [];\n    this.request = req;\n    this.protocol = protocol; // Cache IP since it might not be in the req later\n\n    if (req.websocket && req.websocket._socket) {\n      this.remoteAddress = req.websocket._socket.remoteAddress;\n    } else {\n      this.remoteAddress = req.connection.remoteAddress;\n    }\n\n    this.checkIntervalTimer = null;\n    this.upgradeTimeoutTimer = null;\n    this.pingTimeoutTimer = null;\n    this.pingIntervalTimer = null;\n    this.setTransport(transport);\n    this.onOpen();\n  }\n  /**\n   * Called upon transport considered open.\n   *\n   * @api private\n   */\n\n\n  onOpen() {\n    this.readyState = \"open\"; // sends an `open` packet\n\n    this.transport.sid = this.id;\n    this.sendPacket(\"open\", JSON.stringify({\n      sid: this.id,\n      upgrades: this.getAvailableUpgrades(),\n      pingInterval: this.server.opts.pingInterval,\n      pingTimeout: this.server.opts.pingTimeout\n    }));\n\n    if (this.server.opts.initialPacket) {\n      this.sendPacket(\"message\", this.server.opts.initialPacket);\n    }\n\n    this.emit(\"open\");\n\n    if (this.protocol === 3) {\n      // in protocol v3, the client sends a ping, and the server answers with a pong\n      this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);\n    } else {\n      // in protocol v4, the server sends a ping, and the client answers with a pong\n      this.schedulePing();\n    }\n  }\n  /**\n   * Called upon transport packet.\n   *\n   * @param {Object} packet\n   * @api private\n   */\n\n\n  onPacket(packet) {\n    if (\"open\" !== this.readyState) {\n      return debug(\"packet received with closed socket\");\n    } // export packet event\n\n\n    debug(`received packet ${packet.type}`);\n    this.emit(\"packet\", packet); // Reset ping timeout on any packet, incoming data is a good sign of\n    // other side's liveness\n\n    this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);\n\n    switch (packet.type) {\n      case \"ping\":\n        if (this.transport.protocol !== 3) {\n          this.onError(\"invalid heartbeat direction\");\n          return;\n        }\n\n        debug(\"got ping\");\n        this.sendPacket(\"pong\");\n        this.emit(\"heartbeat\");\n        break;\n\n      case \"pong\":\n        if (this.transport.protocol === 3) {\n          this.onError(\"invalid heartbeat direction\");\n          return;\n        }\n\n        debug(\"got pong\");\n        this.schedulePing();\n        this.emit(\"heartbeat\");\n        break;\n\n      case \"error\":\n        this.onClose(\"parse error\");\n        break;\n\n      case \"message\":\n        this.emit(\"data\", packet.data);\n        this.emit(\"message\", packet.data);\n        break;\n    }\n  }\n  /**\n   * Called upon transport error.\n   *\n   * @param {Error} error object\n   * @api private\n   */\n\n\n  onError(err) {\n    debug(\"transport error\");\n    this.onClose(\"transport error\", err);\n  }\n  /**\n   * Pings client every `this.pingInterval` and expects response\n   * within `this.pingTimeout` or closes connection.\n   *\n   * @api private\n   */\n\n\n  schedulePing() {\n    clearTimeout(this.pingIntervalTimer);\n    this.pingIntervalTimer = setTimeout(() => {\n      debug(\"writing ping packet - expecting pong within %sms\", this.server.opts.pingTimeout);\n      this.sendPacket(\"ping\");\n      this.resetPingTimeout(this.server.opts.pingTimeout);\n    }, this.server.opts.pingInterval);\n  }\n  /**\n   * Resets ping timeout.\n   *\n   * @api private\n   */\n\n\n  resetPingTimeout(timeout) {\n    clearTimeout(this.pingTimeoutTimer);\n    this.pingTimeoutTimer = setTimeout(() => {\n      if (this.readyState === \"closed\") return;\n      this.onClose(\"ping timeout\");\n    }, timeout);\n  }\n  /**\n   * Attaches handlers for the given transport.\n   *\n   * @param {Transport} transport\n   * @api private\n   */\n\n\n  setTransport(transport) {\n    const onError = this.onError.bind(this);\n    const onPacket = this.onPacket.bind(this);\n    const flush = this.flush.bind(this);\n    const onClose = this.onClose.bind(this, \"transport close\");\n    this.transport = transport;\n    this.transport.once(\"error\", onError);\n    this.transport.on(\"packet\", onPacket);\n    this.transport.on(\"drain\", flush);\n    this.transport.once(\"close\", onClose); // this function will manage packet events (also message callbacks)\n\n    this.setupSendCallback();\n    this.cleanupFn.push(function () {\n      transport.removeListener(\"error\", onError);\n      transport.removeListener(\"packet\", onPacket);\n      transport.removeListener(\"drain\", flush);\n      transport.removeListener(\"close\", onClose);\n    });\n  }\n  /**\n   * Upgrades socket to the given transport\n   *\n   * @param {Transport} transport\n   * @api private\n   */\n\n\n  maybeUpgrade(transport) {\n    debug('might upgrade socket transport from \"%s\" to \"%s\"', this.transport.name, transport.name);\n    this.upgrading = true; // set transport upgrade timer\n\n    this.upgradeTimeoutTimer = setTimeout(() => {\n      debug(\"client did not complete upgrade - closing transport\");\n      cleanup();\n\n      if (\"open\" === transport.readyState) {\n        transport.close();\n      }\n    }, this.server.opts.upgradeTimeout);\n\n    const onPacket = packet => {\n      if (\"ping\" === packet.type && \"probe\" === packet.data) {\n        transport.send([{\n          type: \"pong\",\n          data: \"probe\"\n        }]);\n        this.emit(\"upgrading\", transport);\n        clearInterval(this.checkIntervalTimer);\n        this.checkIntervalTimer = setInterval(check, 100);\n      } else if (\"upgrade\" === packet.type && this.readyState !== \"closed\") {\n        debug(\"got upgrade packet - upgrading\");\n        cleanup();\n        this.transport.discard();\n        this.upgraded = true;\n        this.clearTransport();\n        this.setTransport(transport);\n        this.emit(\"upgrade\", transport);\n        this.flush();\n\n        if (this.readyState === \"closing\") {\n          transport.close(() => {\n            this.onClose(\"forced close\");\n          });\n        }\n      } else {\n        cleanup();\n        transport.close();\n      }\n    }; // we force a polling cycle to ensure a fast upgrade\n\n\n    const check = () => {\n      if (\"polling\" === this.transport.name && this.transport.writable) {\n        debug(\"writing a noop packet to polling for fast upgrade\");\n        this.transport.send([{\n          type: \"noop\"\n        }]);\n      }\n    };\n\n    const cleanup = () => {\n      this.upgrading = false;\n      clearInterval(this.checkIntervalTimer);\n      this.checkIntervalTimer = null;\n      clearTimeout(this.upgradeTimeoutTimer);\n      this.upgradeTimeoutTimer = null;\n      transport.removeListener(\"packet\", onPacket);\n      transport.removeListener(\"close\", onTransportClose);\n      transport.removeListener(\"error\", onError);\n      this.removeListener(\"close\", onClose);\n    };\n\n    const onError = err => {\n      debug(\"client did not complete upgrade - %s\", err);\n      cleanup();\n      transport.close();\n      transport = null;\n    };\n\n    const onTransportClose = () => {\n      onError(\"transport closed\");\n    };\n\n    const onClose = () => {\n      onError(\"socket closed\");\n    };\n\n    transport.on(\"packet\", onPacket);\n    transport.once(\"close\", onTransportClose);\n    transport.once(\"error\", onError);\n    this.once(\"close\", onClose);\n  }\n  /**\n   * Clears listeners and timers associated with current transport.\n   *\n   * @api private\n   */\n\n\n  clearTransport() {\n    let cleanup;\n    const toCleanUp = this.cleanupFn.length;\n\n    for (let i = 0; i < toCleanUp; i++) {\n      cleanup = this.cleanupFn.shift();\n      cleanup();\n    } // silence further transport errors and prevent uncaught exceptions\n\n\n    this.transport.on(\"error\", function () {\n      debug(\"error triggered by discarded transport\");\n    }); // ensure transport won't stay open\n\n    this.transport.close();\n    clearTimeout(this.pingTimeoutTimer);\n  }\n  /**\n   * Called upon transport considered closed.\n   * Possible reasons: `ping timeout`, `client error`, `parse error`,\n   * `transport error`, `server close`, `transport close`\n   */\n\n\n  onClose(reason, description) {\n    if (\"closed\" !== this.readyState) {\n      this.readyState = \"closed\"; // clear timers\n\n      clearTimeout(this.pingIntervalTimer);\n      clearTimeout(this.pingTimeoutTimer);\n      clearInterval(this.checkIntervalTimer);\n      this.checkIntervalTimer = null;\n      clearTimeout(this.upgradeTimeoutTimer); // clean writeBuffer in next tick, so developers can still\n      // grab the writeBuffer on 'close' event\n\n      process.nextTick(() => {\n        this.writeBuffer = [];\n      });\n      this.packetsFn = [];\n      this.sentCallbackFn = [];\n      this.clearTransport();\n      this.emit(\"close\", reason, description);\n    }\n  }\n  /**\n   * Setup and manage send callback\n   *\n   * @api private\n   */\n\n\n  setupSendCallback() {\n    // the message was sent successfully, execute the callback\n    const onDrain = () => {\n      if (this.sentCallbackFn.length > 0) {\n        const seqFn = this.sentCallbackFn.splice(0, 1)[0];\n\n        if (\"function\" === typeof seqFn) {\n          debug(\"executing send callback\");\n          seqFn(this.transport);\n        } else if (Array.isArray(seqFn)) {\n          debug(\"executing batch send callback\");\n          const l = seqFn.length;\n          let i = 0;\n\n          for (; i < l; i++) {\n            if (\"function\" === typeof seqFn[i]) {\n              seqFn[i](this.transport);\n            }\n          }\n        }\n      }\n    };\n\n    this.transport.on(\"drain\", onDrain);\n    this.cleanupFn.push(() => {\n      this.transport.removeListener(\"drain\", onDrain);\n    });\n  }\n  /**\n   * Sends a message packet.\n   *\n   * @param {String} message\n   * @param {Object} options\n   * @param {Function} callback\n   * @return {Socket} for chaining\n   * @api public\n   */\n\n\n  send(data, options, callback) {\n    this.sendPacket(\"message\", data, options, callback);\n    return this;\n  }\n\n  write(data, options, callback) {\n    this.sendPacket(\"message\", data, options, callback);\n    return this;\n  }\n  /**\n   * Sends a packet.\n   *\n   * @param {String} packet type\n   * @param {String} optional, data\n   * @param {Object} options\n   * @api private\n   */\n\n\n  sendPacket(type, data, options, callback) {\n    if (\"function\" === typeof options) {\n      callback = options;\n      options = null;\n    }\n\n    options = options || {};\n    options.compress = false !== options.compress;\n\n    if (\"closing\" !== this.readyState && \"closed\" !== this.readyState) {\n      debug('sending packet \"%s\" (%s)', type, data);\n      const packet = {\n        type: type,\n        options: options\n      };\n      if (data) packet.data = data; // exports packetCreate event\n\n      this.emit(\"packetCreate\", packet);\n      this.writeBuffer.push(packet); // add send callback to object, if defined\n\n      if (callback) this.packetsFn.push(callback);\n      this.flush();\n    }\n  }\n  /**\n   * Attempts to flush the packets buffer.\n   *\n   * @api private\n   */\n\n\n  flush() {\n    if (\"closed\" !== this.readyState && this.transport.writable && this.writeBuffer.length) {\n      debug(\"flushing buffer to transport\");\n      this.emit(\"flush\", this.writeBuffer);\n      this.server.emit(\"flush\", this, this.writeBuffer);\n      const wbuf = this.writeBuffer;\n      this.writeBuffer = [];\n\n      if (!this.transport.supportsFraming) {\n        this.sentCallbackFn.push(this.packetsFn);\n      } else {\n        this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);\n      }\n\n      this.packetsFn = [];\n      this.transport.send(wbuf);\n      this.emit(\"drain\");\n      this.server.emit(\"drain\", this);\n    }\n  }\n  /**\n   * Get available upgrades for this socket.\n   *\n   * @api private\n   */\n\n\n  getAvailableUpgrades() {\n    const availableUpgrades = [];\n    const allUpgrades = this.server.upgrades(this.transport.name);\n    let i = 0;\n    const l = allUpgrades.length;\n\n    for (; i < l; ++i) {\n      const upg = allUpgrades[i];\n\n      if (this.server.opts.transports.indexOf(upg) !== -1) {\n        availableUpgrades.push(upg);\n      }\n    }\n\n    return availableUpgrades;\n  }\n  /**\n   * Closes the socket and underlying transport.\n   *\n   * @param {Boolean} optional, discard\n   * @return {Socket} for chaining\n   * @api public\n   */\n\n\n  close(discard) {\n    if (\"open\" !== this.readyState) return;\n    this.readyState = \"closing\";\n\n    if (this.writeBuffer.length) {\n      this.once(\"drain\", this.closeTransport.bind(this, discard));\n      return;\n    }\n\n    this.closeTransport(discard);\n  }\n  /**\n   * Closes the underlying transport.\n   *\n   * @param {Boolean} discard\n   * @api private\n   */\n\n\n  closeTransport(discard) {\n    if (discard) this.transport.discard();\n    this.transport.close(this.onClose.bind(this, \"forced close\"));\n  }\n\n}\n\nmodule.exports = Socket;","map":{"version":3,"sources":["/home/krishnadevz/redocs/client/node_modules/engine.io/lib/socket.js"],"names":["EventEmitter","require","debug","Socket","constructor","id","server","transport","req","protocol","upgrading","upgraded","readyState","writeBuffer","packetsFn","sentCallbackFn","cleanupFn","request","websocket","_socket","remoteAddress","connection","checkIntervalTimer","upgradeTimeoutTimer","pingTimeoutTimer","pingIntervalTimer","setTransport","onOpen","sid","sendPacket","JSON","stringify","upgrades","getAvailableUpgrades","pingInterval","opts","pingTimeout","initialPacket","emit","resetPingTimeout","schedulePing","onPacket","packet","type","onError","onClose","data","err","clearTimeout","setTimeout","timeout","bind","flush","once","on","setupSendCallback","push","removeListener","maybeUpgrade","name","cleanup","close","upgradeTimeout","send","clearInterval","setInterval","check","discard","clearTransport","writable","onTransportClose","toCleanUp","length","i","shift","reason","description","process","nextTick","onDrain","seqFn","splice","Array","isArray","l","options","callback","write","compress","wbuf","supportsFraming","apply","availableUpgrades","allUpgrades","upg","transports","indexOf","closeTransport","module","exports"],"mappings":"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","sourcesContent":["const EventEmitter = require(\"events\");\nconst debug = require(\"debug\")(\"engine:socket\");\n\nclass Socket extends EventEmitter {\n  /**\n   * Client class (abstract).\n   *\n   * @api private\n   */\n  constructor(id, server, transport, req, protocol) {\n    super();\n    this.id = id;\n    this.server = server;\n    this.upgrading = false;\n    this.upgraded = false;\n    this.readyState = \"opening\";\n    this.writeBuffer = [];\n    this.packetsFn = [];\n    this.sentCallbackFn = [];\n    this.cleanupFn = [];\n    this.request = req;\n    this.protocol = protocol;\n\n    // Cache IP since it might not be in the req later\n    if (req.websocket && req.websocket._socket) {\n      this.remoteAddress = req.websocket._socket.remoteAddress;\n    } else {\n      this.remoteAddress = req.connection.remoteAddress;\n    }\n\n    this.checkIntervalTimer = null;\n    this.upgradeTimeoutTimer = null;\n    this.pingTimeoutTimer = null;\n    this.pingIntervalTimer = null;\n\n    this.setTransport(transport);\n    this.onOpen();\n  }\n\n  /**\n   * Called upon transport considered open.\n   *\n   * @api private\n   */\n  onOpen() {\n    this.readyState = \"open\";\n\n    // sends an `open` packet\n    this.transport.sid = this.id;\n    this.sendPacket(\n      \"open\",\n      JSON.stringify({\n        sid: this.id,\n        upgrades: this.getAvailableUpgrades(),\n        pingInterval: this.server.opts.pingInterval,\n        pingTimeout: this.server.opts.pingTimeout\n      })\n    );\n\n    if (this.server.opts.initialPacket) {\n      this.sendPacket(\"message\", this.server.opts.initialPacket);\n    }\n\n    this.emit(\"open\");\n\n    if (this.protocol === 3) {\n      // in protocol v3, the client sends a ping, and the server answers with a pong\n      this.resetPingTimeout(\n        this.server.opts.pingInterval + this.server.opts.pingTimeout\n      );\n    } else {\n      // in protocol v4, the server sends a ping, and the client answers with a pong\n      this.schedulePing();\n    }\n  }\n\n  /**\n   * Called upon transport packet.\n   *\n   * @param {Object} packet\n   * @api private\n   */\n  onPacket(packet) {\n    if (\"open\" !== this.readyState) {\n      return debug(\"packet received with closed socket\");\n    }\n    // export packet event\n    debug(`received packet ${packet.type}`);\n    this.emit(\"packet\", packet);\n\n    // Reset ping timeout on any packet, incoming data is a good sign of\n    // other side's liveness\n    this.resetPingTimeout(\n      this.server.opts.pingInterval + this.server.opts.pingTimeout\n    );\n\n    switch (packet.type) {\n      case \"ping\":\n        if (this.transport.protocol !== 3) {\n          this.onError(\"invalid heartbeat direction\");\n          return;\n        }\n        debug(\"got ping\");\n        this.sendPacket(\"pong\");\n        this.emit(\"heartbeat\");\n        break;\n\n      case \"pong\":\n        if (this.transport.protocol === 3) {\n          this.onError(\"invalid heartbeat direction\");\n          return;\n        }\n        debug(\"got pong\");\n        this.schedulePing();\n        this.emit(\"heartbeat\");\n        break;\n\n      case \"error\":\n        this.onClose(\"parse error\");\n        break;\n\n      case \"message\":\n        this.emit(\"data\", packet.data);\n        this.emit(\"message\", packet.data);\n        break;\n    }\n  }\n\n  /**\n   * Called upon transport error.\n   *\n   * @param {Error} error object\n   * @api private\n   */\n  onError(err) {\n    debug(\"transport error\");\n    this.onClose(\"transport error\", err);\n  }\n\n  /**\n   * Pings client every `this.pingInterval` and expects response\n   * within `this.pingTimeout` or closes connection.\n   *\n   * @api private\n   */\n  schedulePing() {\n    clearTimeout(this.pingIntervalTimer);\n    this.pingIntervalTimer = setTimeout(() => {\n      debug(\n        \"writing ping packet - expecting pong within %sms\",\n        this.server.opts.pingTimeout\n      );\n      this.sendPacket(\"ping\");\n      this.resetPingTimeout(this.server.opts.pingTimeout);\n    }, this.server.opts.pingInterval);\n  }\n\n  /**\n   * Resets ping timeout.\n   *\n   * @api private\n   */\n  resetPingTimeout(timeout) {\n    clearTimeout(this.pingTimeoutTimer);\n    this.pingTimeoutTimer = setTimeout(() => {\n      if (this.readyState === \"closed\") return;\n      this.onClose(\"ping timeout\");\n    }, timeout);\n  }\n\n  /**\n   * Attaches handlers for the given transport.\n   *\n   * @param {Transport} transport\n   * @api private\n   */\n  setTransport(transport) {\n    const onError = this.onError.bind(this);\n    const onPacket = this.onPacket.bind(this);\n    const flush = this.flush.bind(this);\n    const onClose = this.onClose.bind(this, \"transport close\");\n\n    this.transport = transport;\n    this.transport.once(\"error\", onError);\n    this.transport.on(\"packet\", onPacket);\n    this.transport.on(\"drain\", flush);\n    this.transport.once(\"close\", onClose);\n    // this function will manage packet events (also message callbacks)\n    this.setupSendCallback();\n\n    this.cleanupFn.push(function() {\n      transport.removeListener(\"error\", onError);\n      transport.removeListener(\"packet\", onPacket);\n      transport.removeListener(\"drain\", flush);\n      transport.removeListener(\"close\", onClose);\n    });\n  }\n\n  /**\n   * Upgrades socket to the given transport\n   *\n   * @param {Transport} transport\n   * @api private\n   */\n  maybeUpgrade(transport) {\n    debug(\n      'might upgrade socket transport from \"%s\" to \"%s\"',\n      this.transport.name,\n      transport.name\n    );\n\n    this.upgrading = true;\n\n    // set transport upgrade timer\n    this.upgradeTimeoutTimer = setTimeout(() => {\n      debug(\"client did not complete upgrade - closing transport\");\n      cleanup();\n      if (\"open\" === transport.readyState) {\n        transport.close();\n      }\n    }, this.server.opts.upgradeTimeout);\n\n    const onPacket = packet => {\n      if (\"ping\" === packet.type && \"probe\" === packet.data) {\n        transport.send([{ type: \"pong\", data: \"probe\" }]);\n        this.emit(\"upgrading\", transport);\n        clearInterval(this.checkIntervalTimer);\n        this.checkIntervalTimer = setInterval(check, 100);\n      } else if (\"upgrade\" === packet.type && this.readyState !== \"closed\") {\n        debug(\"got upgrade packet - upgrading\");\n        cleanup();\n        this.transport.discard();\n        this.upgraded = true;\n        this.clearTransport();\n        this.setTransport(transport);\n        this.emit(\"upgrade\", transport);\n        this.flush();\n        if (this.readyState === \"closing\") {\n          transport.close(() => {\n            this.onClose(\"forced close\");\n          });\n        }\n      } else {\n        cleanup();\n        transport.close();\n      }\n    };\n\n    // we force a polling cycle to ensure a fast upgrade\n    const check = () => {\n      if (\"polling\" === this.transport.name && this.transport.writable) {\n        debug(\"writing a noop packet to polling for fast upgrade\");\n        this.transport.send([{ type: \"noop\" }]);\n      }\n    };\n\n    const cleanup = () => {\n      this.upgrading = false;\n\n      clearInterval(this.checkIntervalTimer);\n      this.checkIntervalTimer = null;\n\n      clearTimeout(this.upgradeTimeoutTimer);\n      this.upgradeTimeoutTimer = null;\n\n      transport.removeListener(\"packet\", onPacket);\n      transport.removeListener(\"close\", onTransportClose);\n      transport.removeListener(\"error\", onError);\n      this.removeListener(\"close\", onClose);\n    };\n\n    const onError = err => {\n      debug(\"client did not complete upgrade - %s\", err);\n      cleanup();\n      transport.close();\n      transport = null;\n    };\n\n    const onTransportClose = () => {\n      onError(\"transport closed\");\n    };\n\n    const onClose = () => {\n      onError(\"socket closed\");\n    };\n\n    transport.on(\"packet\", onPacket);\n    transport.once(\"close\", onTransportClose);\n    transport.once(\"error\", onError);\n\n    this.once(\"close\", onClose);\n  }\n\n  /**\n   * Clears listeners and timers associated with current transport.\n   *\n   * @api private\n   */\n  clearTransport() {\n    let cleanup;\n\n    const toCleanUp = this.cleanupFn.length;\n\n    for (let i = 0; i < toCleanUp; i++) {\n      cleanup = this.cleanupFn.shift();\n      cleanup();\n    }\n\n    // silence further transport errors and prevent uncaught exceptions\n    this.transport.on(\"error\", function() {\n      debug(\"error triggered by discarded transport\");\n    });\n\n    // ensure transport won't stay open\n    this.transport.close();\n\n    clearTimeout(this.pingTimeoutTimer);\n  }\n\n  /**\n   * Called upon transport considered closed.\n   * Possible reasons: `ping timeout`, `client error`, `parse error`,\n   * `transport error`, `server close`, `transport close`\n   */\n  onClose(reason, description) {\n    if (\"closed\" !== this.readyState) {\n      this.readyState = \"closed\";\n\n      // clear timers\n      clearTimeout(this.pingIntervalTimer);\n      clearTimeout(this.pingTimeoutTimer);\n\n      clearInterval(this.checkIntervalTimer);\n      this.checkIntervalTimer = null;\n      clearTimeout(this.upgradeTimeoutTimer);\n      // clean writeBuffer in next tick, so developers can still\n      // grab the writeBuffer on 'close' event\n      process.nextTick(() => {\n        this.writeBuffer = [];\n      });\n      this.packetsFn = [];\n      this.sentCallbackFn = [];\n      this.clearTransport();\n      this.emit(\"close\", reason, description);\n    }\n  }\n\n  /**\n   * Setup and manage send callback\n   *\n   * @api private\n   */\n  setupSendCallback() {\n    // the message was sent successfully, execute the callback\n    const onDrain = () => {\n      if (this.sentCallbackFn.length > 0) {\n        const seqFn = this.sentCallbackFn.splice(0, 1)[0];\n        if (\"function\" === typeof seqFn) {\n          debug(\"executing send callback\");\n          seqFn(this.transport);\n        } else if (Array.isArray(seqFn)) {\n          debug(\"executing batch send callback\");\n          const l = seqFn.length;\n          let i = 0;\n          for (; i < l; i++) {\n            if (\"function\" === typeof seqFn[i]) {\n              seqFn[i](this.transport);\n            }\n          }\n        }\n      }\n    };\n\n    this.transport.on(\"drain\", onDrain);\n\n    this.cleanupFn.push(() => {\n      this.transport.removeListener(\"drain\", onDrain);\n    });\n  }\n\n  /**\n   * Sends a message packet.\n   *\n   * @param {String} message\n   * @param {Object} options\n   * @param {Function} callback\n   * @return {Socket} for chaining\n   * @api public\n   */\n  send(data, options, callback) {\n    this.sendPacket(\"message\", data, options, callback);\n    return this;\n  }\n\n  write(data, options, callback) {\n    this.sendPacket(\"message\", data, options, callback);\n    return this;\n  }\n\n  /**\n   * Sends a packet.\n   *\n   * @param {String} packet type\n   * @param {String} optional, data\n   * @param {Object} options\n   * @api private\n   */\n  sendPacket(type, data, options, callback) {\n    if (\"function\" === typeof options) {\n      callback = options;\n      options = null;\n    }\n\n    options = options || {};\n    options.compress = false !== options.compress;\n\n    if (\"closing\" !== this.readyState && \"closed\" !== this.readyState) {\n      debug('sending packet \"%s\" (%s)', type, data);\n\n      const packet = {\n        type: type,\n        options: options\n      };\n      if (data) packet.data = data;\n\n      // exports packetCreate event\n      this.emit(\"packetCreate\", packet);\n\n      this.writeBuffer.push(packet);\n\n      // add send callback to object, if defined\n      if (callback) this.packetsFn.push(callback);\n\n      this.flush();\n    }\n  }\n\n  /**\n   * Attempts to flush the packets buffer.\n   *\n   * @api private\n   */\n  flush() {\n    if (\n      \"closed\" !== this.readyState &&\n      this.transport.writable &&\n      this.writeBuffer.length\n    ) {\n      debug(\"flushing buffer to transport\");\n      this.emit(\"flush\", this.writeBuffer);\n      this.server.emit(\"flush\", this, this.writeBuffer);\n      const wbuf = this.writeBuffer;\n      this.writeBuffer = [];\n      if (!this.transport.supportsFraming) {\n        this.sentCallbackFn.push(this.packetsFn);\n      } else {\n        this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);\n      }\n      this.packetsFn = [];\n      this.transport.send(wbuf);\n      this.emit(\"drain\");\n      this.server.emit(\"drain\", this);\n    }\n  }\n\n  /**\n   * Get available upgrades for this socket.\n   *\n   * @api private\n   */\n  getAvailableUpgrades() {\n    const availableUpgrades = [];\n    const allUpgrades = this.server.upgrades(this.transport.name);\n    let i = 0;\n    const l = allUpgrades.length;\n    for (; i < l; ++i) {\n      const upg = allUpgrades[i];\n      if (this.server.opts.transports.indexOf(upg) !== -1) {\n        availableUpgrades.push(upg);\n      }\n    }\n    return availableUpgrades;\n  }\n\n  /**\n   * Closes the socket and underlying transport.\n   *\n   * @param {Boolean} optional, discard\n   * @return {Socket} for chaining\n   * @api public\n   */\n  close(discard) {\n    if (\"open\" !== this.readyState) return;\n\n    this.readyState = \"closing\";\n\n    if (this.writeBuffer.length) {\n      this.once(\"drain\", this.closeTransport.bind(this, discard));\n      return;\n    }\n\n    this.closeTransport(discard);\n  }\n\n  /**\n   * Closes the underlying transport.\n   *\n   * @param {Boolean} discard\n   * @api private\n   */\n  closeTransport(discard) {\n    if (discard) this.transport.discard();\n    this.transport.close(this.onClose.bind(this, \"forced close\"));\n  }\n}\n\nmodule.exports = Socket;\n"]},"metadata":{},"sourceType":"script"}