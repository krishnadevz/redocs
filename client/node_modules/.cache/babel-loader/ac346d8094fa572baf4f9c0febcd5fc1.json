{"ast":null,"code":"const qs = require(\"querystring\");\n\nconst parse = require(\"url\").parse;\n\nconst base64id = require(\"base64id\");\n\nconst transports = require(\"./transports\");\n\nconst EventEmitter = require(\"events\").EventEmitter;\n\nconst Socket = require(\"./socket\");\n\nconst debug = require(\"debug\")(\"engine\");\n\nconst cookieMod = require(\"cookie\");\n\nconst DEFAULT_WS_ENGINE = require(\"ws\").Server;\n\nclass Server extends EventEmitter {\n  /**\n   * Server constructor.\n   *\n   * @param {Object} options\n   * @api public\n   */\n  constructor(opts = {}) {\n    super();\n    this.clients = {};\n    this.clientsCount = 0;\n    this.opts = Object.assign({\n      wsEngine: DEFAULT_WS_ENGINE,\n      pingTimeout: 20000,\n      pingInterval: 25000,\n      upgradeTimeout: 10000,\n      maxHttpBufferSize: 1e6,\n      transports: Object.keys(transports),\n      allowUpgrades: true,\n      httpCompression: {\n        threshold: 1024\n      },\n      cors: false,\n      allowEIO3: false\n    }, opts);\n\n    if (opts.cookie) {\n      this.opts.cookie = Object.assign({\n        name: \"io\",\n        path: \"/\",\n        httpOnly: opts.cookie.path !== false,\n        sameSite: \"lax\"\n      }, opts.cookie);\n    }\n\n    if (this.opts.cors) {\n      this.corsMiddleware = require(\"cors\")(this.opts.cors);\n    }\n\n    if (opts.perMessageDeflate) {\n      this.opts.perMessageDeflate = Object.assign({\n        threshold: 1024\n      }, opts.perMessageDeflate);\n    }\n\n    this.init();\n  }\n  /**\n   * Initialize websocket server\n   *\n   * @api private\n   */\n\n\n  init() {\n    if (!~this.opts.transports.indexOf(\"websocket\")) return;\n    if (this.ws) this.ws.close();\n    this.ws = new this.opts.wsEngine({\n      noServer: true,\n      clientTracking: false,\n      perMessageDeflate: this.opts.perMessageDeflate,\n      maxPayload: this.opts.maxHttpBufferSize\n    });\n\n    if (typeof this.ws.on === \"function\") {\n      this.ws.on(\"headers\", (headersArray, req) => {\n        // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)\n        // we could also try to parse the array and then sync the values, but that will be error-prone\n        const additionalHeaders = {};\n        const isInitialRequest = !req._query.sid;\n\n        if (isInitialRequest) {\n          this.emit(\"initial_headers\", additionalHeaders, req);\n        }\n\n        this.emit(\"headers\", additionalHeaders, req);\n        Object.keys(additionalHeaders).forEach(key => {\n          headersArray.push(`${key}: ${additionalHeaders[key]}`);\n        });\n      });\n    }\n  }\n  /**\n   * Returns a list of available transports for upgrade given a certain transport.\n   *\n   * @return {Array}\n   * @api public\n   */\n\n\n  upgrades(transport) {\n    if (!this.opts.allowUpgrades) return [];\n    return transports[transport].upgradesTo || [];\n  }\n  /**\n   * Verifies a request.\n   *\n   * @param {http.IncomingMessage}\n   * @return {Boolean} whether the request is valid\n   * @api private\n   */\n\n\n  verify(req, upgrade, fn) {\n    // transport check\n    const transport = req._query.transport;\n\n    if (!~this.opts.transports.indexOf(transport)) {\n      debug('unknown transport \"%s\"', transport);\n      return fn(Server.errors.UNKNOWN_TRANSPORT, {\n        transport\n      });\n    } // 'Origin' header check\n\n\n    const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n\n    if (isOriginInvalid) {\n      const origin = req.headers.origin;\n      req.headers.origin = null;\n      debug(\"origin header invalid\");\n      return fn(Server.errors.BAD_REQUEST, {\n        name: \"INVALID_ORIGIN\",\n        origin\n      });\n    } // sid check\n\n\n    const sid = req._query.sid;\n\n    if (sid) {\n      if (!this.clients.hasOwnProperty(sid)) {\n        debug('unknown sid \"%s\"', sid);\n        return fn(Server.errors.UNKNOWN_SID, {\n          sid\n        });\n      }\n\n      const previousTransport = this.clients[sid].transport.name;\n\n      if (!upgrade && previousTransport !== transport) {\n        debug(\"bad request: unexpected transport without upgrade\");\n        return fn(Server.errors.BAD_REQUEST, {\n          name: \"TRANSPORT_MISMATCH\",\n          transport,\n          previousTransport\n        });\n      }\n    } else {\n      // handshake is GET only\n      if (\"GET\" !== req.method) {\n        return fn(Server.errors.BAD_HANDSHAKE_METHOD, {\n          method: req.method\n        });\n      }\n\n      if (!this.opts.allowRequest) return fn();\n      return this.opts.allowRequest(req, (message, success) => {\n        if (!success) {\n          return fn(Server.errors.FORBIDDEN, {\n            message\n          });\n        }\n\n        fn();\n      });\n    }\n\n    fn();\n  }\n  /**\n   * Prepares a request by processing the query string.\n   *\n   * @api private\n   */\n\n\n  prepare(req) {\n    // try to leverage pre-existing `req._query` (e.g: from connect)\n    if (!req._query) {\n      req._query = ~req.url.indexOf(\"?\") ? qs.parse(parse(req.url).query) : {};\n    }\n  }\n  /**\n   * Closes all clients.\n   *\n   * @api public\n   */\n\n\n  close() {\n    debug(\"closing all open clients\");\n\n    for (let i in this.clients) {\n      if (this.clients.hasOwnProperty(i)) {\n        this.clients[i].close(true);\n      }\n    }\n\n    if (this.ws) {\n      debug(\"closing webSocketServer\");\n      this.ws.close(); // don't delete this.ws because it can be used again if the http server starts listening again\n    }\n\n    return this;\n  }\n  /**\n   * Handles an Engine.IO HTTP request.\n   *\n   * @param {http.IncomingMessage} request\n   * @param {http.ServerResponse|http.OutgoingMessage} response\n   * @api public\n   */\n\n\n  handleRequest(req, res) {\n    debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n    this.prepare(req);\n    req.res = res;\n\n    const callback = (errorCode, errorContext) => {\n      if (errorCode !== undefined) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        abortRequest(res, errorCode, errorContext);\n        return;\n      }\n\n      if (req._query.sid) {\n        debug(\"setting new request for existing client\");\n\n        this.clients[req._query.sid].transport.onRequest(req);\n      } else {\n        const closeConnection = (errorCode, errorContext) => abortRequest(res, errorCode, errorContext);\n\n        this.handshake(req._query.transport, req, closeConnection);\n      }\n    };\n\n    if (this.corsMiddleware) {\n      this.corsMiddleware.call(null, req, res, () => {\n        this.verify(req, false, callback);\n      });\n    } else {\n      this.verify(req, false, callback);\n    }\n  }\n  /**\n   * generate a socket id.\n   * Overwrite this method to generate your custom socket id\n   *\n   * @param {Object} request object\n   * @api public\n   */\n\n\n  generateId(req) {\n    return base64id.generateId();\n  }\n  /**\n   * Handshakes a new client.\n   *\n   * @param {String} transport name\n   * @param {Object} request object\n   * @param {Function} closeConnection\n   *\n   * @api private\n   */\n\n\n  async handshake(transportName, req, closeConnection) {\n    const protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n\n    if (protocol === 3 && !this.opts.allowEIO3) {\n      debug(\"unsupported protocol version\");\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,\n        message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],\n        context: {\n          protocol\n        }\n      });\n      closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);\n      return;\n    }\n\n    let id;\n\n    try {\n      id = await this.generateId(req);\n    } catch (e) {\n      debug(\"error while generating an id\");\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.BAD_REQUEST,\n        message: Server.errorMessages[Server.errors.BAD_REQUEST],\n        context: {\n          name: \"ID_GENERATION_ERROR\",\n          error: e\n        }\n      });\n      closeConnection(Server.errors.BAD_REQUEST);\n      return;\n    }\n\n    debug('handshaking client \"%s\"', id);\n\n    try {\n      var transport = new transports[transportName](req);\n\n      if (\"polling\" === transportName) {\n        transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\n        transport.httpCompression = this.opts.httpCompression;\n      } else if (\"websocket\" === transportName) {\n        transport.perMessageDeflate = this.opts.perMessageDeflate;\n      }\n\n      if (req._query && req._query.b64) {\n        transport.supportsBinary = false;\n      } else {\n        transport.supportsBinary = true;\n      }\n    } catch (e) {\n      debug('error handshaking to transport \"%s\"', transportName);\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.BAD_REQUEST,\n        message: Server.errorMessages[Server.errors.BAD_REQUEST],\n        context: {\n          name: \"TRANSPORT_HANDSHAKE_ERROR\",\n          error: e\n        }\n      });\n      closeConnection(Server.errors.BAD_REQUEST);\n      return;\n    }\n\n    const socket = new Socket(id, this, transport, req, protocol);\n    transport.on(\"headers\", (headers, req) => {\n      const isInitialRequest = !req._query.sid;\n\n      if (isInitialRequest) {\n        if (this.opts.cookie) {\n          headers[\"Set-Cookie\"] = [cookieMod.serialize(this.opts.cookie.name, id, this.opts.cookie)];\n        }\n\n        this.emit(\"initial_headers\", headers, req);\n      }\n\n      this.emit(\"headers\", headers, req);\n    });\n    transport.onRequest(req);\n    this.clients[id] = socket;\n    this.clientsCount++;\n    socket.once(\"close\", () => {\n      delete this.clients[id];\n      this.clientsCount--;\n    });\n    this.emit(\"connection\", socket);\n  }\n  /**\n   * Handles an Engine.IO HTTP Upgrade.\n   *\n   * @api public\n   */\n\n\n  handleUpgrade(req, socket, upgradeHead) {\n    this.prepare(req);\n    this.verify(req, true, (errorCode, errorContext) => {\n      if (errorCode) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        abortUpgrade(socket, errorCode, errorContext);\n        return;\n      }\n\n      const head = Buffer.from(upgradeHead); // eslint-disable-line node/no-deprecated-api\n\n      upgradeHead = null; // delegate to ws\n\n      this.ws.handleUpgrade(req, socket, head, websocket => {\n        this.onWebSocket(req, socket, websocket);\n      });\n    });\n  }\n  /**\n   * Called upon a ws.io connection.\n   *\n   * @param {ws.Socket} websocket\n   * @api private\n   */\n\n\n  onWebSocket(req, socket, websocket) {\n    websocket.on(\"error\", onUpgradeError);\n\n    if (transports[req._query.transport] !== undefined && !transports[req._query.transport].prototype.handlesUpgrades) {\n      debug(\"transport doesnt handle upgraded requests\");\n      websocket.close();\n      return;\n    } // get client id\n\n\n    const id = req._query.sid; // keep a reference to the ws.Socket\n\n    req.websocket = websocket;\n\n    if (id) {\n      const client = this.clients[id];\n\n      if (!client) {\n        debug(\"upgrade attempt for closed client\");\n        websocket.close();\n      } else if (client.upgrading) {\n        debug(\"transport has already been trying to upgrade\");\n        websocket.close();\n      } else if (client.upgraded) {\n        debug(\"transport had already been upgraded\");\n        websocket.close();\n      } else {\n        debug(\"upgrading existing transport\"); // transport error handling takes over\n\n        websocket.removeListener(\"error\", onUpgradeError);\n        const transport = new transports[req._query.transport](req);\n\n        if (req._query && req._query.b64) {\n          transport.supportsBinary = false;\n        } else {\n          transport.supportsBinary = true;\n        }\n\n        transport.perMessageDeflate = this.perMessageDeflate;\n        client.maybeUpgrade(transport);\n      }\n    } else {\n      // transport error handling takes over\n      websocket.removeListener(\"error\", onUpgradeError);\n\n      const closeConnection = (errorCode, errorContext) => abortUpgrade(socket, errorCode, errorContext);\n\n      this.handshake(req._query.transport, req, closeConnection);\n    }\n\n    function onUpgradeError() {\n      debug(\"websocket error before upgrade\"); // websocket.close() not needed\n    }\n  }\n  /**\n   * Captures upgrade requests for a http.Server.\n   *\n   * @param {http.Server} server\n   * @param {Object} options\n   * @api public\n   */\n\n\n  attach(server, options = {}) {\n    let path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\n    const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000; // normalize path\n\n    path += \"/\";\n\n    function check(req) {\n      return path === req.url.substr(0, path.length);\n    } // cache and clean up listeners\n\n\n    const listeners = server.listeners(\"request\").slice(0);\n    server.removeAllListeners(\"request\");\n    server.on(\"close\", this.close.bind(this));\n    server.on(\"listening\", this.init.bind(this)); // add request handler\n\n    server.on(\"request\", (req, res) => {\n      if (check(req)) {\n        debug('intercepting request for path \"%s\"', path);\n        this.handleRequest(req, res);\n      } else {\n        let i = 0;\n        const l = listeners.length;\n\n        for (; i < l; i++) {\n          listeners[i].call(server, req, res);\n        }\n      }\n    });\n\n    if (~this.opts.transports.indexOf(\"websocket\")) {\n      server.on(\"upgrade\", (req, socket, head) => {\n        if (check(req)) {\n          this.handleUpgrade(req, socket, head);\n        } else if (false !== options.destroyUpgrade) {\n          // default node behavior is to disconnect when no handlers\n          // but by adding a handler, we prevent that\n          // and if no eio thing handles the upgrade\n          // then the socket needs to die!\n          setTimeout(function () {\n            if (socket.writable && socket.bytesWritten <= 0) {\n              return socket.end();\n            }\n          }, destroyUpgradeTimeout);\n        }\n      });\n    }\n  }\n\n}\n/**\n * Protocol errors mappings.\n */\n\n\nServer.errors = {\n  UNKNOWN_TRANSPORT: 0,\n  UNKNOWN_SID: 1,\n  BAD_HANDSHAKE_METHOD: 2,\n  BAD_REQUEST: 3,\n  FORBIDDEN: 4,\n  UNSUPPORTED_PROTOCOL_VERSION: 5\n};\nServer.errorMessages = {\n  0: \"Transport unknown\",\n  1: \"Session ID unknown\",\n  2: \"Bad handshake method\",\n  3: \"Bad request\",\n  4: \"Forbidden\",\n  5: \"Unsupported protocol version\"\n};\n/**\n * Close the HTTP long-polling request\n *\n * @param res - the response object\n * @param errorCode - the error code\n * @param errorContext - additional error context\n *\n * @api private\n */\n\nfunction abortRequest(res, errorCode, errorContext) {\n  const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;\n  const message = errorContext && errorContext.message ? errorContext.message : Server.errorMessages[errorCode];\n  res.writeHead(statusCode, {\n    \"Content-Type\": \"application/json\"\n  });\n  res.end(JSON.stringify({\n    code: errorCode,\n    message\n  }));\n}\n/**\n * Close the WebSocket connection\n *\n * @param {net.Socket} socket\n * @param {string} errorCode - the error code\n * @param {object} errorContext - additional error context\n *\n * @api private\n */\n\n\nfunction abortUpgrade(socket, errorCode, errorContext = {}) {\n  socket.on(\"error\", () => {\n    debug(\"ignoring error from closed connection\");\n  });\n\n  if (socket.writable) {\n    const message = errorContext.message || Server.errorMessages[errorCode];\n    const length = Buffer.byteLength(message);\n    socket.write(\"HTTP/1.1 400 Bad Request\\r\\n\" + \"Connection: close\\r\\n\" + \"Content-type: text/html\\r\\n\" + \"Content-Length: \" + length + \"\\r\\n\" + \"\\r\\n\" + message);\n  }\n\n  socket.destroy();\n}\n\nmodule.exports = Server;\n/* eslint-disable */\n\n/**\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\n *\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n// prettier-ignore\n\nconst validHdrChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, // 0 - 15\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 32 - 47\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 48 - 63\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 80 - 95\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, // 112 - 127\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 128 ...\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // ... 255\n];\n\nfunction checkInvalidHeaderChar(val) {\n  val += \"\";\n  if (val.length < 1) return false;\n\n  if (!validHdrChars[val.charCodeAt(0)]) {\n    debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\n    return true;\n  }\n\n  if (val.length < 2) return false;\n\n  if (!validHdrChars[val.charCodeAt(1)]) {\n    debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\n    return true;\n  }\n\n  if (val.length < 3) return false;\n\n  if (!validHdrChars[val.charCodeAt(2)]) {\n    debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\n    return true;\n  }\n\n  if (val.length < 4) return false;\n\n  if (!validHdrChars[val.charCodeAt(3)]) {\n    debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\n    return true;\n  }\n\n  for (let i = 4; i < val.length; ++i) {\n    if (!validHdrChars[val.charCodeAt(i)]) {\n      debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\n      return true;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/home/krishnadevz/redocs/client/node_modules/engine.io/lib/server.js"],"names":["qs","require","parse","base64id","transports","EventEmitter","Socket","debug","cookieMod","DEFAULT_WS_ENGINE","Server","constructor","opts","clients","clientsCount","Object","assign","wsEngine","pingTimeout","pingInterval","upgradeTimeout","maxHttpBufferSize","keys","allowUpgrades","httpCompression","threshold","cors","allowEIO3","cookie","name","path","httpOnly","sameSite","corsMiddleware","perMessageDeflate","init","indexOf","ws","close","noServer","clientTracking","maxPayload","on","headersArray","req","additionalHeaders","isInitialRequest","_query","sid","emit","forEach","key","push","upgrades","transport","upgradesTo","verify","upgrade","fn","errors","UNKNOWN_TRANSPORT","isOriginInvalid","checkInvalidHeaderChar","headers","origin","BAD_REQUEST","hasOwnProperty","UNKNOWN_SID","previousTransport","method","BAD_HANDSHAKE_METHOD","allowRequest","message","success","FORBIDDEN","prepare","url","query","i","handleRequest","res","callback","errorCode","errorContext","undefined","code","errorMessages","context","abortRequest","onRequest","closeConnection","handshake","call","generateId","transportName","protocol","EIO","UNSUPPORTED_PROTOCOL_VERSION","id","e","error","b64","supportsBinary","socket","serialize","once","handleUpgrade","upgradeHead","abortUpgrade","head","Buffer","from","websocket","onWebSocket","onUpgradeError","prototype","handlesUpgrades","client","upgrading","upgraded","removeListener","maybeUpgrade","attach","server","options","replace","destroyUpgradeTimeout","check","substr","length","listeners","slice","removeAllListeners","bind","l","destroyUpgrade","setTimeout","writable","bytesWritten","end","statusCode","writeHead","JSON","stringify","byteLength","write","destroy","module","exports","validHdrChars","val","charCodeAt"],"mappings":"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","sourcesContent":["const qs = require(\"querystring\");\nconst parse = require(\"url\").parse;\nconst base64id = require(\"base64id\");\nconst transports = require(\"./transports\");\nconst EventEmitter = require(\"events\").EventEmitter;\nconst Socket = require(\"./socket\");\nconst debug = require(\"debug\")(\"engine\");\nconst cookieMod = require(\"cookie\");\n\nconst DEFAULT_WS_ENGINE = require(\"ws\").Server;\n\nclass Server extends EventEmitter {\n  /**\n   * Server constructor.\n   *\n   * @param {Object} options\n   * @api public\n   */\n  constructor(opts = {}) {\n    super();\n\n    this.clients = {};\n    this.clientsCount = 0;\n\n    this.opts = Object.assign(\n      {\n        wsEngine: DEFAULT_WS_ENGINE,\n        pingTimeout: 20000,\n        pingInterval: 25000,\n        upgradeTimeout: 10000,\n        maxHttpBufferSize: 1e6,\n        transports: Object.keys(transports),\n        allowUpgrades: true,\n        httpCompression: {\n          threshold: 1024\n        },\n        cors: false,\n        allowEIO3: false\n      },\n      opts\n    );\n\n    if (opts.cookie) {\n      this.opts.cookie = Object.assign(\n        {\n          name: \"io\",\n          path: \"/\",\n          httpOnly: opts.cookie.path !== false,\n          sameSite: \"lax\"\n        },\n        opts.cookie\n      );\n    }\n\n    if (this.opts.cors) {\n      this.corsMiddleware = require(\"cors\")(this.opts.cors);\n    }\n\n    if (opts.perMessageDeflate) {\n      this.opts.perMessageDeflate = Object.assign(\n        {\n          threshold: 1024\n        },\n        opts.perMessageDeflate\n      );\n    }\n\n    this.init();\n  }\n\n  /**\n   * Initialize websocket server\n   *\n   * @api private\n   */\n  init() {\n    if (!~this.opts.transports.indexOf(\"websocket\")) return;\n\n    if (this.ws) this.ws.close();\n\n    this.ws = new this.opts.wsEngine({\n      noServer: true,\n      clientTracking: false,\n      perMessageDeflate: this.opts.perMessageDeflate,\n      maxPayload: this.opts.maxHttpBufferSize\n    });\n\n    if (typeof this.ws.on === \"function\") {\n      this.ws.on(\"headers\", (headersArray, req) => {\n        // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)\n        // we could also try to parse the array and then sync the values, but that will be error-prone\n        const additionalHeaders = {};\n\n        const isInitialRequest = !req._query.sid;\n        if (isInitialRequest) {\n          this.emit(\"initial_headers\", additionalHeaders, req);\n        }\n\n        this.emit(\"headers\", additionalHeaders, req);\n\n        Object.keys(additionalHeaders).forEach(key => {\n          headersArray.push(`${key}: ${additionalHeaders[key]}`);\n        });\n      });\n    }\n  }\n\n  /**\n   * Returns a list of available transports for upgrade given a certain transport.\n   *\n   * @return {Array}\n   * @api public\n   */\n  upgrades(transport) {\n    if (!this.opts.allowUpgrades) return [];\n    return transports[transport].upgradesTo || [];\n  }\n\n  /**\n   * Verifies a request.\n   *\n   * @param {http.IncomingMessage}\n   * @return {Boolean} whether the request is valid\n   * @api private\n   */\n  verify(req, upgrade, fn) {\n    // transport check\n    const transport = req._query.transport;\n    if (!~this.opts.transports.indexOf(transport)) {\n      debug('unknown transport \"%s\"', transport);\n      return fn(Server.errors.UNKNOWN_TRANSPORT, { transport });\n    }\n\n    // 'Origin' header check\n    const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n    if (isOriginInvalid) {\n      const origin = req.headers.origin;\n      req.headers.origin = null;\n      debug(\"origin header invalid\");\n      return fn(Server.errors.BAD_REQUEST, {\n        name: \"INVALID_ORIGIN\",\n        origin\n      });\n    }\n\n    // sid check\n    const sid = req._query.sid;\n    if (sid) {\n      if (!this.clients.hasOwnProperty(sid)) {\n        debug('unknown sid \"%s\"', sid);\n        return fn(Server.errors.UNKNOWN_SID, {\n          sid\n        });\n      }\n      const previousTransport = this.clients[sid].transport.name;\n      if (!upgrade && previousTransport !== transport) {\n        debug(\"bad request: unexpected transport without upgrade\");\n        return fn(Server.errors.BAD_REQUEST, {\n          name: \"TRANSPORT_MISMATCH\",\n          transport,\n          previousTransport\n        });\n      }\n    } else {\n      // handshake is GET only\n      if (\"GET\" !== req.method) {\n        return fn(Server.errors.BAD_HANDSHAKE_METHOD, {\n          method: req.method\n        });\n      }\n\n      if (!this.opts.allowRequest) return fn();\n\n      return this.opts.allowRequest(req, (message, success) => {\n        if (!success) {\n          return fn(Server.errors.FORBIDDEN, {\n            message\n          });\n        }\n        fn();\n      });\n    }\n\n    fn();\n  }\n\n  /**\n   * Prepares a request by processing the query string.\n   *\n   * @api private\n   */\n  prepare(req) {\n    // try to leverage pre-existing `req._query` (e.g: from connect)\n    if (!req._query) {\n      req._query = ~req.url.indexOf(\"?\") ? qs.parse(parse(req.url).query) : {};\n    }\n  }\n\n  /**\n   * Closes all clients.\n   *\n   * @api public\n   */\n  close() {\n    debug(\"closing all open clients\");\n    for (let i in this.clients) {\n      if (this.clients.hasOwnProperty(i)) {\n        this.clients[i].close(true);\n      }\n    }\n    if (this.ws) {\n      debug(\"closing webSocketServer\");\n      this.ws.close();\n      // don't delete this.ws because it can be used again if the http server starts listening again\n    }\n    return this;\n  }\n\n  /**\n   * Handles an Engine.IO HTTP request.\n   *\n   * @param {http.IncomingMessage} request\n   * @param {http.ServerResponse|http.OutgoingMessage} response\n   * @api public\n   */\n  handleRequest(req, res) {\n    debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n    this.prepare(req);\n    req.res = res;\n\n    const callback = (errorCode, errorContext) => {\n      if (errorCode !== undefined) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        abortRequest(res, errorCode, errorContext);\n        return;\n      }\n\n      if (req._query.sid) {\n        debug(\"setting new request for existing client\");\n        this.clients[req._query.sid].transport.onRequest(req);\n      } else {\n        const closeConnection = (errorCode, errorContext) =>\n          abortRequest(res, errorCode, errorContext);\n        this.handshake(req._query.transport, req, closeConnection);\n      }\n    };\n\n    if (this.corsMiddleware) {\n      this.corsMiddleware.call(null, req, res, () => {\n        this.verify(req, false, callback);\n      });\n    } else {\n      this.verify(req, false, callback);\n    }\n  }\n\n  /**\n   * generate a socket id.\n   * Overwrite this method to generate your custom socket id\n   *\n   * @param {Object} request object\n   * @api public\n   */\n  generateId(req) {\n    return base64id.generateId();\n  }\n\n  /**\n   * Handshakes a new client.\n   *\n   * @param {String} transport name\n   * @param {Object} request object\n   * @param {Function} closeConnection\n   *\n   * @api private\n   */\n  async handshake(transportName, req, closeConnection) {\n    const protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n    if (protocol === 3 && !this.opts.allowEIO3) {\n      debug(\"unsupported protocol version\");\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,\n        message:\n          Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],\n        context: {\n          protocol\n        }\n      });\n      closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);\n      return;\n    }\n\n    let id;\n    try {\n      id = await this.generateId(req);\n    } catch (e) {\n      debug(\"error while generating an id\");\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.BAD_REQUEST,\n        message: Server.errorMessages[Server.errors.BAD_REQUEST],\n        context: {\n          name: \"ID_GENERATION_ERROR\",\n          error: e\n        }\n      });\n      closeConnection(Server.errors.BAD_REQUEST);\n      return;\n    }\n\n    debug('handshaking client \"%s\"', id);\n\n    try {\n      var transport = new transports[transportName](req);\n      if (\"polling\" === transportName) {\n        transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\n        transport.httpCompression = this.opts.httpCompression;\n      } else if (\"websocket\" === transportName) {\n        transport.perMessageDeflate = this.opts.perMessageDeflate;\n      }\n\n      if (req._query && req._query.b64) {\n        transport.supportsBinary = false;\n      } else {\n        transport.supportsBinary = true;\n      }\n    } catch (e) {\n      debug('error handshaking to transport \"%s\"', transportName);\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.BAD_REQUEST,\n        message: Server.errorMessages[Server.errors.BAD_REQUEST],\n        context: {\n          name: \"TRANSPORT_HANDSHAKE_ERROR\",\n          error: e\n        }\n      });\n      closeConnection(Server.errors.BAD_REQUEST);\n      return;\n    }\n    const socket = new Socket(id, this, transport, req, protocol);\n\n    transport.on(\"headers\", (headers, req) => {\n      const isInitialRequest = !req._query.sid;\n\n      if (isInitialRequest) {\n        if (this.opts.cookie) {\n          headers[\"Set-Cookie\"] = [\n            cookieMod.serialize(this.opts.cookie.name, id, this.opts.cookie)\n          ];\n        }\n        this.emit(\"initial_headers\", headers, req);\n      }\n      this.emit(\"headers\", headers, req);\n    });\n\n    transport.onRequest(req);\n\n    this.clients[id] = socket;\n    this.clientsCount++;\n\n    socket.once(\"close\", () => {\n      delete this.clients[id];\n      this.clientsCount--;\n    });\n\n    this.emit(\"connection\", socket);\n  }\n\n  /**\n   * Handles an Engine.IO HTTP Upgrade.\n   *\n   * @api public\n   */\n  handleUpgrade(req, socket, upgradeHead) {\n    this.prepare(req);\n\n    this.verify(req, true, (errorCode, errorContext) => {\n      if (errorCode) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        abortUpgrade(socket, errorCode, errorContext);\n        return;\n      }\n\n      const head = Buffer.from(upgradeHead); // eslint-disable-line node/no-deprecated-api\n      upgradeHead = null;\n\n      // delegate to ws\n      this.ws.handleUpgrade(req, socket, head, websocket => {\n        this.onWebSocket(req, socket, websocket);\n      });\n    });\n  }\n\n  /**\n   * Called upon a ws.io connection.\n   *\n   * @param {ws.Socket} websocket\n   * @api private\n   */\n  onWebSocket(req, socket, websocket) {\n    websocket.on(\"error\", onUpgradeError);\n\n    if (\n      transports[req._query.transport] !== undefined &&\n      !transports[req._query.transport].prototype.handlesUpgrades\n    ) {\n      debug(\"transport doesnt handle upgraded requests\");\n      websocket.close();\n      return;\n    }\n\n    // get client id\n    const id = req._query.sid;\n\n    // keep a reference to the ws.Socket\n    req.websocket = websocket;\n\n    if (id) {\n      const client = this.clients[id];\n      if (!client) {\n        debug(\"upgrade attempt for closed client\");\n        websocket.close();\n      } else if (client.upgrading) {\n        debug(\"transport has already been trying to upgrade\");\n        websocket.close();\n      } else if (client.upgraded) {\n        debug(\"transport had already been upgraded\");\n        websocket.close();\n      } else {\n        debug(\"upgrading existing transport\");\n\n        // transport error handling takes over\n        websocket.removeListener(\"error\", onUpgradeError);\n\n        const transport = new transports[req._query.transport](req);\n        if (req._query && req._query.b64) {\n          transport.supportsBinary = false;\n        } else {\n          transport.supportsBinary = true;\n        }\n        transport.perMessageDeflate = this.perMessageDeflate;\n        client.maybeUpgrade(transport);\n      }\n    } else {\n      // transport error handling takes over\n      websocket.removeListener(\"error\", onUpgradeError);\n\n      const closeConnection = (errorCode, errorContext) =>\n        abortUpgrade(socket, errorCode, errorContext);\n      this.handshake(req._query.transport, req, closeConnection);\n    }\n\n    function onUpgradeError() {\n      debug(\"websocket error before upgrade\");\n      // websocket.close() not needed\n    }\n  }\n\n  /**\n   * Captures upgrade requests for a http.Server.\n   *\n   * @param {http.Server} server\n   * @param {Object} options\n   * @api public\n   */\n  attach(server, options = {}) {\n    let path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\n\n    const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;\n\n    // normalize path\n    path += \"/\";\n\n    function check(req) {\n      return path === req.url.substr(0, path.length);\n    }\n\n    // cache and clean up listeners\n    const listeners = server.listeners(\"request\").slice(0);\n    server.removeAllListeners(\"request\");\n    server.on(\"close\", this.close.bind(this));\n    server.on(\"listening\", this.init.bind(this));\n\n    // add request handler\n    server.on(\"request\", (req, res) => {\n      if (check(req)) {\n        debug('intercepting request for path \"%s\"', path);\n        this.handleRequest(req, res);\n      } else {\n        let i = 0;\n        const l = listeners.length;\n        for (; i < l; i++) {\n          listeners[i].call(server, req, res);\n        }\n      }\n    });\n\n    if (~this.opts.transports.indexOf(\"websocket\")) {\n      server.on(\"upgrade\", (req, socket, head) => {\n        if (check(req)) {\n          this.handleUpgrade(req, socket, head);\n        } else if (false !== options.destroyUpgrade) {\n          // default node behavior is to disconnect when no handlers\n          // but by adding a handler, we prevent that\n          // and if no eio thing handles the upgrade\n          // then the socket needs to die!\n          setTimeout(function() {\n            if (socket.writable && socket.bytesWritten <= 0) {\n              return socket.end();\n            }\n          }, destroyUpgradeTimeout);\n        }\n      });\n    }\n  }\n}\n\n/**\n * Protocol errors mappings.\n */\n\nServer.errors = {\n  UNKNOWN_TRANSPORT: 0,\n  UNKNOWN_SID: 1,\n  BAD_HANDSHAKE_METHOD: 2,\n  BAD_REQUEST: 3,\n  FORBIDDEN: 4,\n  UNSUPPORTED_PROTOCOL_VERSION: 5\n};\n\nServer.errorMessages = {\n  0: \"Transport unknown\",\n  1: \"Session ID unknown\",\n  2: \"Bad handshake method\",\n  3: \"Bad request\",\n  4: \"Forbidden\",\n  5: \"Unsupported protocol version\"\n};\n\n/**\n * Close the HTTP long-polling request\n *\n * @param res - the response object\n * @param errorCode - the error code\n * @param errorContext - additional error context\n *\n * @api private\n */\n\nfunction abortRequest(res, errorCode, errorContext) {\n  const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;\n  const message =\n    errorContext && errorContext.message\n      ? errorContext.message\n      : Server.errorMessages[errorCode];\n\n  res.writeHead(statusCode, { \"Content-Type\": \"application/json\" });\n  res.end(\n    JSON.stringify({\n      code: errorCode,\n      message\n    })\n  );\n}\n\n/**\n * Close the WebSocket connection\n *\n * @param {net.Socket} socket\n * @param {string} errorCode - the error code\n * @param {object} errorContext - additional error context\n *\n * @api private\n */\n\nfunction abortUpgrade(socket, errorCode, errorContext = {}) {\n  socket.on(\"error\", () => {\n    debug(\"ignoring error from closed connection\");\n  });\n  if (socket.writable) {\n    const message = errorContext.message || Server.errorMessages[errorCode];\n    const length = Buffer.byteLength(message);\n    socket.write(\n      \"HTTP/1.1 400 Bad Request\\r\\n\" +\n        \"Connection: close\\r\\n\" +\n        \"Content-type: text/html\\r\\n\" +\n        \"Content-Length: \" +\n        length +\n        \"\\r\\n\" +\n        \"\\r\\n\" +\n        message\n    );\n  }\n  socket.destroy();\n}\n\nmodule.exports = Server;\n\n/* eslint-disable */\n\n/**\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\n *\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n// prettier-ignore\nconst validHdrChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 48 - 63\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, // 112 - 127\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 128 ...\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1  // ... 255\n]\n\nfunction checkInvalidHeaderChar(val) {\n  val += \"\";\n  if (val.length < 1) return false;\n  if (!validHdrChars[val.charCodeAt(0)]) {\n    debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\n    return true;\n  }\n  if (val.length < 2) return false;\n  if (!validHdrChars[val.charCodeAt(1)]) {\n    debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\n    return true;\n  }\n  if (val.length < 3) return false;\n  if (!validHdrChars[val.charCodeAt(2)]) {\n    debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\n    return true;\n  }\n  if (val.length < 4) return false;\n  if (!validHdrChars[val.charCodeAt(3)]) {\n    debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\n    return true;\n  }\n  for (let i = 4; i < val.length; ++i) {\n    if (!validHdrChars[val.charCodeAt(i)]) {\n      debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\n      return true;\n    }\n  }\n  return false;\n}\n"]},"metadata":{},"sourceType":"script"}